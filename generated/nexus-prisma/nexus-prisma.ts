/**
 * This file was automatically generated by nexus-prisma@0.3.7
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
  interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
  objectTypes: {
    fields: {
      Query: QueryObject
      Product: ProductObject
      ProductConnection: ProductConnectionObject
      PageInfo: PageInfoObject
      ProductEdge: ProductEdgeObject
      AggregateProduct: AggregateProductObject
      Hero: HeroObject
      HeroConnection: HeroConnectionObject
      HeroEdge: HeroEdgeObject
      AggregateHero: AggregateHeroObject
      Enemy: EnemyObject
      EnemyConnection: EnemyConnectionObject
      EnemyEdge: EnemyEdgeObject
      AggregateEnemy: AggregateEnemyObject
      Mutation: MutationObject
      BatchPayload: BatchPayloadObject
      Subscription: SubscriptionObject
      ProductSubscriptionPayload: ProductSubscriptionPayloadObject
      ProductPreviousValues: ProductPreviousValuesObject
      HeroSubscriptionPayload: HeroSubscriptionPayloadObject
      HeroPreviousValues: HeroPreviousValuesObject
      EnemySubscriptionPayload: EnemySubscriptionPayloadObject
      EnemyPreviousValues: EnemyPreviousValuesObject
    }
    fieldsDetails: {
      Query: QueryFieldDetails
      Product: ProductFieldDetails
      ProductConnection: ProductConnectionFieldDetails
      PageInfo: PageInfoFieldDetails
      ProductEdge: ProductEdgeFieldDetails
      AggregateProduct: AggregateProductFieldDetails
      Hero: HeroFieldDetails
      HeroConnection: HeroConnectionFieldDetails
      HeroEdge: HeroEdgeFieldDetails
      AggregateHero: AggregateHeroFieldDetails
      Enemy: EnemyFieldDetails
      EnemyConnection: EnemyConnectionFieldDetails
      EnemyEdge: EnemyEdgeFieldDetails
      AggregateEnemy: AggregateEnemyFieldDetails
      Mutation: MutationFieldDetails
      BatchPayload: BatchPayloadFieldDetails
      Subscription: SubscriptionFieldDetails
      ProductSubscriptionPayload: ProductSubscriptionPayloadFieldDetails
      ProductPreviousValues: ProductPreviousValuesFieldDetails
      HeroSubscriptionPayload: HeroSubscriptionPayloadFieldDetails
      HeroPreviousValues: HeroPreviousValuesFieldDetails
      EnemySubscriptionPayload: EnemySubscriptionPayloadFieldDetails
      EnemyPreviousValues: EnemyPreviousValuesFieldDetails
    }
  }
  inputTypes: {
    fields: {
      ProductWhereUniqueInput: ProductWhereUniqueInputInputObject
      ProductWhereInput: ProductWhereInputInputObject
      HeroWhereUniqueInput: HeroWhereUniqueInputInputObject
      HeroWhereInput: HeroWhereInputInputObject
      EnemyWhereUniqueInput: EnemyWhereUniqueInputInputObject
      EnemyWhereInput: EnemyWhereInputInputObject
      ProductCreateInput: ProductCreateInputInputObject
      ProductUpdateInput: ProductUpdateInputInputObject
      ProductUpdateManyMutationInput: ProductUpdateManyMutationInputInputObject
      HeroCreateInput: HeroCreateInputInputObject
      ProductCreateOneInput: ProductCreateOneInputInputObject
      HeroUpdateInput: HeroUpdateInputInputObject
      ProductUpdateOneInput: ProductUpdateOneInputInputObject
      ProductUpdateDataInput: ProductUpdateDataInputInputObject
      ProductUpsertNestedInput: ProductUpsertNestedInputInputObject
      HeroUpdateManyMutationInput: HeroUpdateManyMutationInputInputObject
      EnemyCreateInput: EnemyCreateInputInputObject
      EnemyUpdateInput: EnemyUpdateInputInputObject
      EnemyUpdateManyMutationInput: EnemyUpdateManyMutationInputInputObject
      ProductSubscriptionWhereInput: ProductSubscriptionWhereInputInputObject
      HeroSubscriptionWhereInput: HeroSubscriptionWhereInputInputObject
      EnemySubscriptionWhereInput: EnemySubscriptionWhereInputInputObject
    }
  }
  enumTypes: {
    ProductOrderByInput: ProductOrderByInputValues,
    HeroOrderByInput: HeroOrderByInputValues,
    EnemyOrderByInput: EnemyOrderByInputValues,
    MutationType: MutationTypeValues,
  }
}

// Types for Query

type QueryObject =
  | QueryFields
  | { name: 'product', args?: QueryProductArgs[] | false, alias?: string  } 
  | { name: 'products', args?: QueryProductsArgs[] | false, alias?: string  } 
  | { name: 'productsConnection', args?: QueryProductsConnectionArgs[] | false, alias?: string  } 
  | { name: 'hero', args?: QueryHeroArgs[] | false, alias?: string  } 
  | { name: 'heroes', args?: QueryHeroesArgs[] | false, alias?: string  } 
  | { name: 'heroesConnection', args?: QueryHeroesConnectionArgs[] | false, alias?: string  } 
  | { name: 'enemy', args?: QueryEnemyArgs[] | false, alias?: string  } 
  | { name: 'enemies', args?: QueryEnemiesArgs[] | false, alias?: string  } 
  | { name: 'enemiesConnection', args?: QueryEnemiesConnectionArgs[] | false, alias?: string  } 

type QueryFields =
  | 'product'
  | 'products'
  | 'productsConnection'
  | 'hero'
  | 'heroes'
  | 'heroesConnection'
  | 'enemy'
  | 'enemies'
  | 'enemiesConnection'


type QueryProductArgs =
  | 'where'
type QueryProductsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryProductsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryHeroArgs =
  | 'where'
type QueryHeroesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryHeroesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryEnemyArgs =
  | 'where'
type QueryEnemiesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryEnemiesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface QueryFieldDetails {
  product: {
    type: 'Product'
    args: Record<QueryProductArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: ProductWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product | null> | prisma.Product | null
  }
  products: {
    type: 'Product'
    args: Record<QueryProductsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: ProductWhereInput | null, orderBy?: prisma.ProductOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product[]> | prisma.Product[]
  }
  productsConnection: {
    type: 'ProductConnection'
    args: Record<QueryProductsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: ProductWhereInput | null, orderBy?: prisma.ProductOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ProductConnection> | prisma.ProductConnection
  }
  hero: {
    type: 'Hero'
    args: Record<QueryHeroArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: HeroWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Hero | null> | prisma.Hero | null
  }
  heroes: {
    type: 'Hero'
    args: Record<QueryHeroesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: HeroWhereInput | null, orderBy?: prisma.HeroOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Hero[]> | prisma.Hero[]
  }
  heroesConnection: {
    type: 'HeroConnection'
    args: Record<QueryHeroesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: HeroWhereInput | null, orderBy?: prisma.HeroOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.HeroConnection> | prisma.HeroConnection
  }
  enemy: {
    type: 'Enemy'
    args: Record<QueryEnemyArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: EnemyWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Enemy | null> | prisma.Enemy | null
  }
  enemies: {
    type: 'Enemy'
    args: Record<QueryEnemiesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: EnemyWhereInput | null, orderBy?: prisma.EnemyOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Enemy[]> | prisma.Enemy[]
  }
  enemiesConnection: {
    type: 'EnemyConnection'
    args: Record<QueryEnemiesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: EnemyWhereInput | null, orderBy?: prisma.EnemyOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.EnemyConnection> | prisma.EnemyConnection
  }
}
  

// Types for Product

type ProductObject =
  | ProductFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'version', args?: [] | false, alias?: string  } 

type ProductFields =
  | 'id'
  | 'name'
  | 'version'



  

export interface ProductFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  version: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for ProductConnection

type ProductConnectionObject =
  | ProductConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type ProductConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface ProductConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ProductConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'ProductEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"ProductConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ProductEdge[]> | prisma.ProductEdge[]
  }
  aggregate: {
    type: 'AggregateProduct'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ProductConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateProduct> | prisma.AggregateProduct
  }
}
  

// Types for PageInfo

type PageInfoObject =
  | PageInfoFields
  | { name: 'hasNextPage', args?: [] | false, alias?: string  } 
  | { name: 'hasPreviousPage', args?: [] | false, alias?: string  } 
  | { name: 'startCursor', args?: [] | false, alias?: string  } 
  | { name: 'endCursor', args?: [] | false, alias?: string  } 

type PageInfoFields =
  | 'hasNextPage'
  | 'hasPreviousPage'
  | 'startCursor'
  | 'endCursor'



  

export interface PageInfoFieldDetails {
  hasNextPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  hasPreviousPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  endCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for ProductEdge

type ProductEdgeObject =
  | ProductEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type ProductEdgeFields =
  | 'node'
  | 'cursor'



  

export interface ProductEdgeFieldDetails {
  node: {
    type: 'Product'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ProductEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product> | prisma.Product
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateProduct

type AggregateProductObject =
  | AggregateProductFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateProductFields =
  | 'count'



  

export interface AggregateProductFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Hero

type HeroObject =
  | HeroFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'stand', args?: [] | false, alias?: string  } 
  | { name: 'product', args?: [] | false, alias?: string  } 

type HeroFields =
  | 'id'
  | 'name'
  | 'stand'
  | 'product'



  

export interface HeroFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  stand: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  product: {
    type: 'Product'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Hero">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product | null> | prisma.Product | null
  }
}
  

// Types for HeroConnection

type HeroConnectionObject =
  | HeroConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type HeroConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface HeroConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"HeroConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'HeroEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"HeroConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.HeroEdge[]> | prisma.HeroEdge[]
  }
  aggregate: {
    type: 'AggregateHero'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"HeroConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateHero> | prisma.AggregateHero
  }
}
  

// Types for HeroEdge

type HeroEdgeObject =
  | HeroEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type HeroEdgeFields =
  | 'node'
  | 'cursor'



  

export interface HeroEdgeFieldDetails {
  node: {
    type: 'Hero'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"HeroEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Hero> | prisma.Hero
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateHero

type AggregateHeroObject =
  | AggregateHeroFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateHeroFields =
  | 'count'



  

export interface AggregateHeroFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Enemy

type EnemyObject =
  | EnemyFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'stand', args?: [] | false, alias?: string  } 
  | { name: 'product', args?: [] | false, alias?: string  } 

type EnemyFields =
  | 'id'
  | 'name'
  | 'stand'
  | 'product'



  

export interface EnemyFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  stand: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  product: {
    type: 'Product'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Enemy">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product | null> | prisma.Product | null
  }
}
  

// Types for EnemyConnection

type EnemyConnectionObject =
  | EnemyConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type EnemyConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface EnemyConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"EnemyConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'EnemyEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"EnemyConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.EnemyEdge[]> | prisma.EnemyEdge[]
  }
  aggregate: {
    type: 'AggregateEnemy'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"EnemyConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateEnemy> | prisma.AggregateEnemy
  }
}
  

// Types for EnemyEdge

type EnemyEdgeObject =
  | EnemyEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type EnemyEdgeFields =
  | 'node'
  | 'cursor'



  

export interface EnemyEdgeFieldDetails {
  node: {
    type: 'Enemy'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"EnemyEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Enemy> | prisma.Enemy
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateEnemy

type AggregateEnemyObject =
  | AggregateEnemyFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateEnemyFields =
  | 'count'



  

export interface AggregateEnemyFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Mutation

type MutationObject =
  | MutationFields
  | { name: 'createProduct', args?: MutationCreateProductArgs[] | false, alias?: string  } 
  | { name: 'updateProduct', args?: MutationUpdateProductArgs[] | false, alias?: string  } 
  | { name: 'updateManyProducts', args?: MutationUpdateManyProductsArgs[] | false, alias?: string  } 
  | { name: 'upsertProduct', args?: MutationUpsertProductArgs[] | false, alias?: string  } 
  | { name: 'deleteProduct', args?: MutationDeleteProductArgs[] | false, alias?: string  } 
  | { name: 'deleteManyProducts', args?: MutationDeleteManyProductsArgs[] | false, alias?: string  } 
  | { name: 'createHero', args?: MutationCreateHeroArgs[] | false, alias?: string  } 
  | { name: 'updateHero', args?: MutationUpdateHeroArgs[] | false, alias?: string  } 
  | { name: 'updateManyHeroes', args?: MutationUpdateManyHeroesArgs[] | false, alias?: string  } 
  | { name: 'upsertHero', args?: MutationUpsertHeroArgs[] | false, alias?: string  } 
  | { name: 'deleteHero', args?: MutationDeleteHeroArgs[] | false, alias?: string  } 
  | { name: 'deleteManyHeroes', args?: MutationDeleteManyHeroesArgs[] | false, alias?: string  } 
  | { name: 'createEnemy', args?: MutationCreateEnemyArgs[] | false, alias?: string  } 
  | { name: 'updateEnemy', args?: MutationUpdateEnemyArgs[] | false, alias?: string  } 
  | { name: 'updateManyEnemies', args?: MutationUpdateManyEnemiesArgs[] | false, alias?: string  } 
  | { name: 'upsertEnemy', args?: MutationUpsertEnemyArgs[] | false, alias?: string  } 
  | { name: 'deleteEnemy', args?: MutationDeleteEnemyArgs[] | false, alias?: string  } 
  | { name: 'deleteManyEnemies', args?: MutationDeleteManyEnemiesArgs[] | false, alias?: string  } 

type MutationFields =
  | 'createProduct'
  | 'updateProduct'
  | 'updateManyProducts'
  | 'upsertProduct'
  | 'deleteProduct'
  | 'deleteManyProducts'
  | 'createHero'
  | 'updateHero'
  | 'updateManyHeroes'
  | 'upsertHero'
  | 'deleteHero'
  | 'deleteManyHeroes'
  | 'createEnemy'
  | 'updateEnemy'
  | 'updateManyEnemies'
  | 'upsertEnemy'
  | 'deleteEnemy'
  | 'deleteManyEnemies'


type MutationCreateProductArgs =
  | 'data'
type MutationUpdateProductArgs =
  | 'data'
  | 'where'
type MutationUpdateManyProductsArgs =
  | 'data'
  | 'where'
type MutationUpsertProductArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteProductArgs =
  | 'where'
type MutationDeleteManyProductsArgs =
  | 'where'
type MutationCreateHeroArgs =
  | 'data'
type MutationUpdateHeroArgs =
  | 'data'
  | 'where'
type MutationUpdateManyHeroesArgs =
  | 'data'
  | 'where'
type MutationUpsertHeroArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteHeroArgs =
  | 'where'
type MutationDeleteManyHeroesArgs =
  | 'where'
type MutationCreateEnemyArgs =
  | 'data'
type MutationUpdateEnemyArgs =
  | 'data'
  | 'where'
type MutationUpdateManyEnemiesArgs =
  | 'data'
  | 'where'
type MutationUpsertEnemyArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteEnemyArgs =
  | 'where'
type MutationDeleteManyEnemiesArgs =
  | 'where'
  

export interface MutationFieldDetails {
  createProduct: {
    type: 'Product'
    args: Record<MutationCreateProductArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ProductCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product> | prisma.Product
  }
  updateProduct: {
    type: 'Product'
    args: Record<MutationUpdateProductArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ProductUpdateInput, where: ProductWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product | null> | prisma.Product | null
  }
  updateManyProducts: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyProductsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ProductUpdateManyMutationInput, where?: ProductWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertProduct: {
    type: 'Product'
    args: Record<MutationUpsertProductArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: ProductWhereUniqueInput, create: ProductCreateInput, update: ProductUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product> | prisma.Product
  }
  deleteProduct: {
    type: 'Product'
    args: Record<MutationDeleteProductArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: ProductWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product | null> | prisma.Product | null
  }
  deleteManyProducts: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyProductsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: ProductWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createHero: {
    type: 'Hero'
    args: Record<MutationCreateHeroArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: HeroCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Hero> | prisma.Hero
  }
  updateHero: {
    type: 'Hero'
    args: Record<MutationUpdateHeroArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: HeroUpdateInput, where: HeroWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Hero | null> | prisma.Hero | null
  }
  updateManyHeroes: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyHeroesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: HeroUpdateManyMutationInput, where?: HeroWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertHero: {
    type: 'Hero'
    args: Record<MutationUpsertHeroArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: HeroWhereUniqueInput, create: HeroCreateInput, update: HeroUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Hero> | prisma.Hero
  }
  deleteHero: {
    type: 'Hero'
    args: Record<MutationDeleteHeroArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: HeroWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Hero | null> | prisma.Hero | null
  }
  deleteManyHeroes: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyHeroesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: HeroWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createEnemy: {
    type: 'Enemy'
    args: Record<MutationCreateEnemyArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: EnemyCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Enemy> | prisma.Enemy
  }
  updateEnemy: {
    type: 'Enemy'
    args: Record<MutationUpdateEnemyArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: EnemyUpdateInput, where: EnemyWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Enemy | null> | prisma.Enemy | null
  }
  updateManyEnemies: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyEnemiesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: EnemyUpdateManyMutationInput, where?: EnemyWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertEnemy: {
    type: 'Enemy'
    args: Record<MutationUpsertEnemyArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: EnemyWhereUniqueInput, create: EnemyCreateInput, update: EnemyUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Enemy> | prisma.Enemy
  }
  deleteEnemy: {
    type: 'Enemy'
    args: Record<MutationDeleteEnemyArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: EnemyWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Enemy | null> | prisma.Enemy | null
  }
  deleteManyEnemies: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyEnemiesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: EnemyWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
}
  

// Types for BatchPayload

type BatchPayloadObject =
  | BatchPayloadFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type BatchPayloadFields =
  | 'count'



  

export interface BatchPayloadFieldDetails {
  count: {
    type: 'Long'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Subscription

type SubscriptionObject =
  | SubscriptionFields
  | { name: 'product', args?: SubscriptionProductArgs[] | false, alias?: string  } 
  | { name: 'hero', args?: SubscriptionHeroArgs[] | false, alias?: string  } 
  | { name: 'enemy', args?: SubscriptionEnemyArgs[] | false, alias?: string  } 

type SubscriptionFields =
  | 'product'
  | 'hero'
  | 'enemy'


type SubscriptionProductArgs =
  | 'where'
type SubscriptionHeroArgs =
  | 'where'
type SubscriptionEnemyArgs =
  | 'where'
  

export interface SubscriptionFieldDetails {
  product: {
    type: 'ProductSubscriptionPayload'
    args: Record<SubscriptionProductArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: ProductSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ProductSubscriptionPayload | null> | prisma.ProductSubscriptionPayload | null
  }
  hero: {
    type: 'HeroSubscriptionPayload'
    args: Record<SubscriptionHeroArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: HeroSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.HeroSubscriptionPayload | null> | prisma.HeroSubscriptionPayload | null
  }
  enemy: {
    type: 'EnemySubscriptionPayload'
    args: Record<SubscriptionEnemyArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: EnemySubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.EnemySubscriptionPayload | null> | prisma.EnemySubscriptionPayload | null
  }
}
  

// Types for ProductSubscriptionPayload

type ProductSubscriptionPayloadObject =
  | ProductSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type ProductSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface ProductSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ProductSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Product'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"ProductSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Product | null> | prisma.Product | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'ProductPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"ProductSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ProductPreviousValues | null> | prisma.ProductPreviousValues | null
  }
}
  

// Types for ProductPreviousValues

type ProductPreviousValuesObject =
  | ProductPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'version', args?: [] | false, alias?: string  } 

type ProductPreviousValuesFields =
  | 'id'
  | 'name'
  | 'version'



  

export interface ProductPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  version: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for HeroSubscriptionPayload

type HeroSubscriptionPayloadObject =
  | HeroSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type HeroSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface HeroSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"HeroSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Hero'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"HeroSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Hero | null> | prisma.Hero | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'HeroPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"HeroSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.HeroPreviousValues | null> | prisma.HeroPreviousValues | null
  }
}
  

// Types for HeroPreviousValues

type HeroPreviousValuesObject =
  | HeroPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'stand', args?: [] | false, alias?: string  } 

type HeroPreviousValuesFields =
  | 'id'
  | 'name'
  | 'stand'



  

export interface HeroPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  stand: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for EnemySubscriptionPayload

type EnemySubscriptionPayloadObject =
  | EnemySubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type EnemySubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface EnemySubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"EnemySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Enemy'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"EnemySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Enemy | null> | prisma.Enemy | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'EnemyPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"EnemySubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.EnemyPreviousValues | null> | prisma.EnemyPreviousValues | null
  }
}
  

// Types for EnemyPreviousValues

type EnemyPreviousValuesObject =
  | EnemyPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'stand', args?: [] | false, alias?: string  } 

type EnemyPreviousValuesFields =
  | 'id'
  | 'name'
  | 'stand'



  

export interface EnemyPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  stand: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  


export interface ProductWhereUniqueInput {
  id?: string | null
}
export type ProductWhereUniqueInputInputObject =
  | Extract<keyof ProductWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface ProductWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  version?: number | null
  version_not?: number | null
  version_in?: number[]
  version_not_in?: number[]
  version_lt?: number | null
  version_lte?: number | null
  version_gt?: number | null
  version_gte?: number | null
  AND?: ProductWhereInput[]
  OR?: ProductWhereInput[]
  NOT?: ProductWhereInput[]
}
export type ProductWhereInputInputObject =
  | Extract<keyof ProductWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'version', alias?: string  } 
  | { name: 'version_not', alias?: string  } 
  | { name: 'version_in', alias?: string  } 
  | { name: 'version_not_in', alias?: string  } 
  | { name: 'version_lt', alias?: string  } 
  | { name: 'version_lte', alias?: string  } 
  | { name: 'version_gt', alias?: string  } 
  | { name: 'version_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface HeroWhereUniqueInput {
  id?: string | null
}
export type HeroWhereUniqueInputInputObject =
  | Extract<keyof HeroWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface HeroWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  stand?: string | null
  stand_not?: string | null
  stand_in?: string[]
  stand_not_in?: string[]
  stand_lt?: string | null
  stand_lte?: string | null
  stand_gt?: string | null
  stand_gte?: string | null
  stand_contains?: string | null
  stand_not_contains?: string | null
  stand_starts_with?: string | null
  stand_not_starts_with?: string | null
  stand_ends_with?: string | null
  stand_not_ends_with?: string | null
  product?: ProductWhereInput | null
  AND?: HeroWhereInput[]
  OR?: HeroWhereInput[]
  NOT?: HeroWhereInput[]
}
export type HeroWhereInputInputObject =
  | Extract<keyof HeroWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'stand', alias?: string  } 
  | { name: 'stand_not', alias?: string  } 
  | { name: 'stand_in', alias?: string  } 
  | { name: 'stand_not_in', alias?: string  } 
  | { name: 'stand_lt', alias?: string  } 
  | { name: 'stand_lte', alias?: string  } 
  | { name: 'stand_gt', alias?: string  } 
  | { name: 'stand_gte', alias?: string  } 
  | { name: 'stand_contains', alias?: string  } 
  | { name: 'stand_not_contains', alias?: string  } 
  | { name: 'stand_starts_with', alias?: string  } 
  | { name: 'stand_not_starts_with', alias?: string  } 
  | { name: 'stand_ends_with', alias?: string  } 
  | { name: 'stand_not_ends_with', alias?: string  } 
  | { name: 'product', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface EnemyWhereUniqueInput {
  id?: string | null
}
export type EnemyWhereUniqueInputInputObject =
  | Extract<keyof EnemyWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface EnemyWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  stand?: string | null
  stand_not?: string | null
  stand_in?: string[]
  stand_not_in?: string[]
  stand_lt?: string | null
  stand_lte?: string | null
  stand_gt?: string | null
  stand_gte?: string | null
  stand_contains?: string | null
  stand_not_contains?: string | null
  stand_starts_with?: string | null
  stand_not_starts_with?: string | null
  stand_ends_with?: string | null
  stand_not_ends_with?: string | null
  product?: ProductWhereInput | null
  AND?: EnemyWhereInput[]
  OR?: EnemyWhereInput[]
  NOT?: EnemyWhereInput[]
}
export type EnemyWhereInputInputObject =
  | Extract<keyof EnemyWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'stand', alias?: string  } 
  | { name: 'stand_not', alias?: string  } 
  | { name: 'stand_in', alias?: string  } 
  | { name: 'stand_not_in', alias?: string  } 
  | { name: 'stand_lt', alias?: string  } 
  | { name: 'stand_lte', alias?: string  } 
  | { name: 'stand_gt', alias?: string  } 
  | { name: 'stand_gte', alias?: string  } 
  | { name: 'stand_contains', alias?: string  } 
  | { name: 'stand_not_contains', alias?: string  } 
  | { name: 'stand_starts_with', alias?: string  } 
  | { name: 'stand_not_starts_with', alias?: string  } 
  | { name: 'stand_ends_with', alias?: string  } 
  | { name: 'stand_not_ends_with', alias?: string  } 
  | { name: 'product', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface ProductCreateInput {
  id?: string | null
  name?: string
  version?: number
}
export type ProductCreateInputInputObject =
  | Extract<keyof ProductCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'version', alias?: string  } 
  
export interface ProductUpdateInput {
  name?: string | null
  version?: number | null
}
export type ProductUpdateInputInputObject =
  | Extract<keyof ProductUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'version', alias?: string  } 
  
export interface ProductUpdateManyMutationInput {
  name?: string | null
  version?: number | null
}
export type ProductUpdateManyMutationInputInputObject =
  | Extract<keyof ProductUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'version', alias?: string  } 
  
export interface HeroCreateInput {
  id?: string | null
  name?: string
  stand?: string | null
  product?: ProductCreateOneInput | null
}
export type HeroCreateInputInputObject =
  | Extract<keyof HeroCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'stand', alias?: string  } 
  | { name: 'product', alias?: string  } 
  
export interface ProductCreateOneInput {
  create?: ProductCreateInput | null
  connect?: ProductWhereUniqueInput | null
}
export type ProductCreateOneInputInputObject =
  | Extract<keyof ProductCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface HeroUpdateInput {
  name?: string | null
  stand?: string | null
  product?: ProductUpdateOneInput | null
}
export type HeroUpdateInputInputObject =
  | Extract<keyof HeroUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'stand', alias?: string  } 
  | { name: 'product', alias?: string  } 
  
export interface ProductUpdateOneInput {
  create?: ProductCreateInput | null
  update?: ProductUpdateDataInput | null
  upsert?: ProductUpsertNestedInput | null
  delete?: boolean | null
  disconnect?: boolean | null
  connect?: ProductWhereUniqueInput | null
}
export type ProductUpdateOneInputInputObject =
  | Extract<keyof ProductUpdateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface ProductUpdateDataInput {
  name?: string | null
  version?: number | null
}
export type ProductUpdateDataInputInputObject =
  | Extract<keyof ProductUpdateDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'version', alias?: string  } 
  
export interface ProductUpsertNestedInput {
  update?: ProductUpdateDataInput
  create?: ProductCreateInput
}
export type ProductUpsertNestedInputInputObject =
  | Extract<keyof ProductUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface HeroUpdateManyMutationInput {
  name?: string | null
  stand?: string | null
}
export type HeroUpdateManyMutationInputInputObject =
  | Extract<keyof HeroUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'stand', alias?: string  } 
  
export interface EnemyCreateInput {
  id?: string | null
  name?: string
  stand?: string | null
  product?: ProductCreateOneInput | null
}
export type EnemyCreateInputInputObject =
  | Extract<keyof EnemyCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'stand', alias?: string  } 
  | { name: 'product', alias?: string  } 
  
export interface EnemyUpdateInput {
  name?: string | null
  stand?: string | null
  product?: ProductUpdateOneInput | null
}
export type EnemyUpdateInputInputObject =
  | Extract<keyof EnemyUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'stand', alias?: string  } 
  | { name: 'product', alias?: string  } 
  
export interface EnemyUpdateManyMutationInput {
  name?: string | null
  stand?: string | null
}
export type EnemyUpdateManyMutationInputInputObject =
  | Extract<keyof EnemyUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'stand', alias?: string  } 
  
export interface ProductSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: ProductWhereInput | null
  AND?: ProductSubscriptionWhereInput[]
  OR?: ProductSubscriptionWhereInput[]
  NOT?: ProductSubscriptionWhereInput[]
}
export type ProductSubscriptionWhereInputInputObject =
  | Extract<keyof ProductSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface HeroSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: HeroWhereInput | null
  AND?: HeroSubscriptionWhereInput[]
  OR?: HeroSubscriptionWhereInput[]
  NOT?: HeroSubscriptionWhereInput[]
}
export type HeroSubscriptionWhereInputInputObject =
  | Extract<keyof HeroSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface EnemySubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: EnemyWhereInput | null
  AND?: EnemySubscriptionWhereInput[]
  OR?: EnemySubscriptionWhereInput[]
  NOT?: EnemySubscriptionWhereInput[]
}
export type EnemySubscriptionWhereInputInputObject =
  | Extract<keyof EnemySubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  

export type ProductOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'version_ASC'
  | 'version_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type HeroOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'stand_ASC'
  | 'stand_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type EnemyOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'stand_ASC'
  | 'stand_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type MutationTypeValues =
  | 'CREATED'
  | 'UPDATED'
  | 'DELETED'
  
  